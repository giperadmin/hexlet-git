Условные обозначения:
►16 - указатель 1
◄17 - указатель 2
▲30 - предупреждение
▼31 - указание
¶20 - абзац
§21 - параграф
▬22 - черта
■ = alt + 254
▼```````````````````````````````````
код
▲```````````````````````````````````



§3.1 printf
=====================================
%[флаги][ширина][.точность][модификатор]спецификатор




§3.2 scanf
=====================================

scanf("%d",&a);

■ Основные спецификаторы формата:
%d — целые числа типа int;
%f — вещественное число типа float;
%lf — вещественное число типа double (сокращение от long float);
%c — символ.
▲ Не забывайте ставить знак & перед именем переменной!
▲ Символ . является допустимым символом в режиме собирания вещественного числа.
— Режим собирания числа завершается, как только встречается первый символ, который не может быть составной частью числа.
— Если мы не находимся в режиме собирания числа, то любые пробельные символы просто считываются и игнорируются.
■ Пробельными символами являются, например, пробел, перенос строки (\n), горизонтальная табуляция (\t).
▲ При считывании данных по формату %c пробельные символы не игнорируются.
Чтобы проигнорировать пробельные символы при считывании по формату %c нужно перед спецификатором %с добавить пробел, т.е. заменить "%с" на " %c".

И хотя можно добавлять сколько угодно пробельных символов в формат строку, всё же в программах следует избегать лишних пробельных символов в формат-строке. Например, заменить "%d%d" на "%d %d" — нормально, так как это улучшает читаемость строки формата, но писать что-то вроде "\t\n%d\t\t%d" не стоит.

■ Другие символы в формат-строке
Если в формат-строке функции scanf встречается какой-то другой символ (не спецификатор формата и не пробельный символ), то это означает, что в потоке ввода на этом месте должен присутствовать точно такой же символ.
Например, формат-строка вида "%d,%d" означает, что во входном потоке должны быть записаны два целых числа, причём сразу за первым числом должна стоять запятая.

▼ Два основных правила работы с функцией scanf:
— количество спецификаторов формата должно совпадать с количеством данных для ввода;
— спецификаторы формата должны точно соответствовать типами переменных, переданным в функцию scanf.

■ Функция scanf возвращает целое число — количество переменных, в которые функция scanf успешно записала значения из входного потока. Давайте посмотрим на это значение.
values_read = scanf("%d,%d", &a, &b);

int a, b;
float real_f;
double real_d;
char ch;
scanf("%d %d", &a, &b);  // считает два целых числа, эквивалентно scanf("%d%d", &a, &b);
scanf("%d%f", &a, &real_f); // считает целое и вещественное число
scanf(" %c %lf", &ch, &real_d); // считает первый непробельный символ в ch 
                                // и вещественное число в real_d
scanf("%c", &ch); // считает один произвольный символ (включая пробельные символы) в ch
var_count=scanf("%d%d", &a, &b);

▲ Перевод шахматной нотации из "Nb1  -  c3" в |Nc3|
scanf("%c%*c%*d - %c%d", &figure, &x, &y);
printf("|%c%c%d|", figure, x, y);

▲ 
%*c - Читает 1 символ, но не сохраняет (звёздочка говорит "пропустить")
%*d - Читает целое число, но не сохраняет

▲
Чтобы прочитать ровно три цифры (и не больше) из непрерывной последовательности чисел, в scanf нужно указать ширину поля перед спецификатором:
scanf("%3d", &x);

■
▼```````````````````````````````````
//Проверяем количество цифк в числе штатными средствами scanf:
int main() {
  int i, j;
  scanf("%d%n", &i, &j);
  printf("%d", j);
}
▲```````````````````````````````````

§4.1 Арифметика в си
======================================

ОЧЕНЬ краткая шпаргалка по материалам урока
Основные арифметические операторы:
+ -- сложение
- -- вычитание
* -- умножение
/ -- деление (для целых чисел -- целочисленное деление) 
% -- остаток от деления (только для целых чисел)
Ключевые особенности: 

Целочисленное деление
7 / 2 → 3 (делим, а потом отбрасываем дробную часть)

Вещественное деление  
Один из операндов должен быть вещественного типа  
(float) 7 /  2 → 3.5
или:
(double) 7 /  2 → 3.5 // так приходилось писать при решении тестов

Остаток от деления  
Работает ТОЛЬКО с целыми числами.
Знак остатка = знак первого операнда  
-10 % 3 → -1  
10 % -3 → 1

Явное приведение типа
Формат записи:
(имя типа) значение (int) 9.81 → 9 
(имя типа) переменная int x = 5; (float) x → 5.0 
​​​​​​​Нюансы:
В случае с переменной меняет только тип значения, участвующего в выражении. Тип переменной остаётся прежним.
При преобразовании из float/double в int дробная часть отбрасывается

■ Функция abs() работает только с целыми числами
Для дробных чисел нужно использовать
fabs() из <math.h>



§4.4 rand()
======================================
#include <stdio.h>   // чтобы пользоваться функцией printf
#include <stdlib.h>  // чтобы пользоваться функцией rand
int main(void)
{
	printf("%d\n", rand());
	return 0;
}

▲ Чтобы ограничить сверху диапазон генерируемых случайных чисел значением K  возьмите остаток от деления на K + 1:
rand() % (K + 1).

▲ Чтобы ограничить диапазон чисел, генерируемых функцией rand, снизу (слева) числом M используйте формулу M + rand():
printf("%d\n", 80 + rand();.

▲ Если нужно получить числа из отрезка [A, B], то можно воспользоваться следующей конструкцией:
A + rand() % (B - A + 1);.

■ 
srand(time(NULL));
printf("%d\n", 80 + rand()%(100 - 80 + 1));
printf("%d\n", 80 + rand()%(100 - 79));
printf("%d\n", 80 + rand()%21);
printf("%d\n", 80 + rand()%21);
printf("%d\n", 80 + rand()%21);
return 0;



§6.1 switch
======================================

■ общий синтаксис инструкции switch:

switch (управляющее_выражение) {
        case метка_1: [набор_инструкций_1]
        case метка_2: [набор_инструкций_2]
        case метка_3: [набор_инструкций_3]
        case метка_4: [набор_инструкций_4]
        ...
        [default: набор_инструкций_по-умолчанию]
}


■ Ограничения switch

В качестве управляющего выражения можно использовать:
— переменную целого типа, например: int;
— переменную типа char;
— любое выражение, результат которого будет целым числом или символом.

Каждая ветка case внутри инструкции switch должна иметь свою уникальную метку. В качестве метки можно использовать целые числа и одиночные символы:

int num = 3;

case 'a':       // корректно (одиночный символ)
case 7:         // корректно (целое число)
case num:       // ошибка (значение переменной не может быть меткой)
case 3.14:      // ошибка (вещественное число не может быть меткой)
case "A":       // ошибка (строка не может быть меткой)


■ Сквозное выполнение (проваливание) в инструкции switchСквозное выполнение (проваливание) в инструкции switch
<...> если есть совпадение в одной из веток case, то выполняются все инструкции, записанные после этой метки. Т.е. буквально все, ибо про остановку перед следующей меткой ничего не говорилось. Иначе говоря, выполнив все инструкции в текущей ветке программа не останавливается, а как бы "проваливается" в следующую ветку и начинает выполнять уже её инструкции и так до тех пор, пока не достигнет закрывающей скобки }.
Эта фича, унаследованная из языков ассемблера, позволяет писать очень эффективный код.


■ Инструкция break

break называют оператором безусловного выхода. Эта инструкция немедленно прерывает выполнение switch и переходит к коду, расположенному после закрывающей фигурной скобки }.
▲ Добавляйте break в каждую ветку, где нужно избежать "проваливания". Стандартный подход, позволяющий избегать ошибок, состоит в том, чтобы думать будто break это часть синтаксиса инструкции switch (как case) и cначала добавлять break в каждую ветку. И только потом явно удалять break там, где требуется "проваливание".


■ Нюансы switch

Ветка case может быть пустой, т.е. в ней может вовсе не быть инструкций.

<...>
case 'B': //используем проваливание
case 'b': 
    printf("GOOD!\n"); 
    break;
<...>

Пустые ветки и "проваливание" используются когда для различных вариантов нужно выполнить одинаковый код.

<...>
switch (answer) { 
        case 'B': 
        case 'b': 
                printf("GOOD!\n"); 
                break;
        case 'A': /* сквозное выполнение */
        case 'a': 
        case 'C': 
        case 'c': 
        case 'D': 
        case 'd': 
                printf("BAD!\n");
                break;

        default: // Ветка default не является обязательной.

        	printf("ERROR!\n"); 
                break;
}   <...>


■ Ветка default не является обязательной, но лучше всегда добавлять её в конце инструкции switch.

■ Вложенные switch
Инструкции switch могут быть вложенными, т.е. в любой ветке switch мы снова можем использовать switch.
▲ Инструкция break выходит только из текущей инструкции switch.




§6.2 Отношекния и логические операторы
======================================

>  — больше чем
>= — больше чем или равно
<  — меньше чем
<= — меньше чем или равно
== — равно
!= — не равно
!  — логическое НЕ
&& — логическое И
|| — логическое ИЛИ

■ В логических выражениях любое значение, отличное от числа нуль, интерпретируется как ИСТИНА.
Числа 0 и 0.0 интерпретируются как ЛОЖЬ.


■ Приоритет операторов сравнения и логических операторов

Операторы сравнения и логические операторы также имеют определённый приоритет.

действия в скобках ()
явное приведение типов
вызов и вычисление функций (например, sqrt(), cos() и пр.)
логическое НЕ !
умножение *, деление /, остаток от деления %
сложение +, вычитание -
сравнения <, >, <=, >=
проверка равенства и неравенства ==, !=
логическое И &&
логическое ИЛИ ||
присваивание =




§6.3 Условные инструкции: if-else
======================================

В ветках if-else можно использовать любые инструкции языка Си, в том числе и if-else.

#include <stdio.h>

int main(void)
{
        double x;
        scanf("%lf", &x); 
        
        if (x < 0) {
                printf("%f\n", -x);
        } else {
                printf("%f\n", x);
        }      

        return 0;
}

Ветка else всегда относится к ближайшему if, у которого нет своего else.

■ Лесенка из вложенных if-else
▼```````````````````````````````````
#include <stdio.h>

int main(void)
{
        int score, new_score;
        scanf("%d", &score);

        if (score >= 90) {
                new_score = 5;
        } else if (score >= 70) {
                new_score = 4;
        } else if (score >= 50) {
                new_score = 3;
        } else {
                new_score = 2;
        }

        printf("score: %d\n", new_score);

        return 0;
}
▲```````````````````````````````````
■ Пример со сравниванием с учётом погрешностей вычислений и округлений:
▼```````````````````````````````````
//Проверка, что n — степень двойки
#include <stdio.h>
int main(void)
{
    int n=0;
    scanf("%d",&n);
    double x = log2(n); 
    if (fabs(x - round(x)) < 1e-12) printf("YES\n");
    else printf("NO\n");
    return 0;
}
▲```````````````````````````````````



§7.1 Цикл со счётчиком for
======================================
Цикл for состоит из двух частей: заголовок цикла (первая строка) и тело цикла (вторая строка).
Тело цикла — это команда, которую необходимо выполнить несколько раз. Если необходимо выполнить несколько команд, а не одну, то можно воспользоваться составным оператором { }.

for (инициализация счетчика; условие; изменение счетчика)
  {оператор;}

for (int m = 255; m >= 0; m = m - 5)



§7.2 Цикл с предусловием while
======================================
▼```````````````````````````````````
while (условие)
  оператор;
▲```````````````````````````````````
Работает эта конструкция следующим образом:

Программа встречает ключевое слово while, значит дальше идёт циклическая конструкция;
Проверяется условие. Вычисляется логическое выражение, записанное в скобках;
Если значение условия ИСТИНА, то выполняется тело цикла. После выполнения тела цикла переходим к пункту 2;
Если значение условия ЛОЖЬ, то цикл завершается. Управление передаётся на оператор, следующий за телом цикла.
Под оператором понимается один оператор. Если нужно выполнить в цикле несколько команд, то, как обычно, необходимо использовать составной оператор { }.

Цикл while называют циклом с предусловием, т.к. прежде, чем выполнить тело цикла, проверяется условие. Это значит, например, что возможна такая ситуация, что тело цикла не выполнится вообще ни один раз.



§7.2а Цикл с постусловием do-while
======================================
Данный цикл отличается от цикла while тем, что условие проверяется не перед выполнением тела цикла, а после выполнения тела цикла. Это значит, что тело цикла do-while выполнится хотя бы один раз обязательно.
▼```````````````````````````````````
do
  оператор;
while (условие);
▲```````````````````````````````````

Работает эта конструкция следующим образом:

Программа встречает ключевое слово do. Значит перед ней цикл do-while;
Выполняется тело цикла;
Проверяется условие;
Если условие ИСТИНА,то снова выполняется тело цикла;
Если условие ЛОЖЬ, то работа циклической конструкции прекращается. Программы выполняет оператор, следующий за циклом do-while.



§7.3 Операторы управления циклом. Зацикливание
======================================
Существует два оператора, которые позволяют управлять выполнением цикла. Это операторы break и continue.

■ break — прекращает выполнение цикла, как в switch

Оператор break работает и во всех циклических конструкциях, и в операторе выбора.

Оператор break всегда завершает ближайший внешний оператор, внутри которого он находится.

■ continue — применяется только внутри циклов. Он позволяет прервать текущую итерацию цикла. После того, как компьютер встречает оператор continue, он завершает исполнение тела цикла и переходит к проверке условия (в циклах while и do-while) или к изменению счётчика (выражение 3 в цикле for).




§8.1 Массивы одномерные
======================================
У массива, как и у переменной, имеются свои имя и тип данных. Кроме того, у массива ещё есть одна дополнительная характеристика — размер массива. Размер массива — количество элементов, которые могут в нём храниться.
— нумерация элементов массива начинается с нуля


■ Объявление и инициализация массива
—Объявление массива очень похоже на объявление переменной. Отличие лишь в том, что следует дополнительно указать размер массива в квадратных скобках.
— имя массива — любая последовательность символов, цифр и знака нижнего подчеркивания _, которая начинается с буквы. Регистр букв важен.
— Массиву, как и любой переменной, можно присвоить начальные значения при объявлении. Если элементам массива не присвоить никакого значения, то в них будет храниться мусор, как и в обычных переменных.

int arr_int[8];
double arr_float[11];
float number[2000];

int grades[50], order[10];
double prices[500];

int arr_int[5] = {2, 5, 5, 3, 4};
double arr_float[11] = {1.2, -2.3, 4.5, 3.83, 0.01, -0.12, 44.2, 123.7, 23.44, -3.7, 7};

Если нужно присвоить нулевые значения всем элементам массива:
double arr[50] = {0};

■ Работа с отдельными элементами массива
Чтобы обратиться к отдельному элементу массива, необходимо написать его имя и порядковый номер в квадратных скобках. 

#include <stdio.h>
int main(void){
  int arr[5] = {2, 4, 3, 5, 5};
  printf("%d %d %d %d %d\n",arr[0], arr[1], arr[2], arr[3], arr[4]);
  return(0);
}

#include <stdio.h>
int main(void){
  int arr[100] = {0};
  for(int i = 0; i < 100; i = i + 1){
    arr[i] = 2*i;}
  for(int i = 0; i < 100; i = i + 1){
    printf("%d\t",arr[i]);}
  return(0);
}

■ использование массива для хранения статистики выпадения случайных чисел:

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {
  srand(time(NULL));
  int count[3] = {0};
  int rand_number;

  for (int i = 0; i < 100000; i = i + 1){
    rand_number = rand()%3;
    count[rand_number] = count[rand_number] + 1;
  }

  for(int i = 0; i < 3; i = i + 1){
    printf("%d - %d\n", i, count[i]);
  }

  return 0;
}




§8.2 Массивы двумерные
======================================

