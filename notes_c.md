Условные обозначения:
►16 - указатель 1
◄17 - указатель 2
▲30 - предупреждение
▼31 - указание
¶20 - абзац
§21 - параграф
▬22 - черта
■ = alt + 254




§3.1 printf
=====================================
%[флаги][ширина][.точность][модификатор]спецификатор




§3.2 scanf
=====================================

scanf("%d",&a);

■ Основные спецификаторы формата:
%d — целые числа типа int;
%f — вещественное число типа float;
%lf — вещественное число типа double (сокращение от long float);
%c — символ.
▲ Не забывайте ставить знак & перед именем переменной!
▲ Символ . является допустимым символом в режиме собирания вещественного числа.
— Режим собирания числа завершается, как только встречается первый символ, который не может быть составной частью числа.
— Если мы не находимся в режиме собирания числа, то любые пробельные символы просто считываются и игнорируются.
■ Пробельными символами являются, например, пробел, перенос строки (\n), горизонтальная табуляция (\t).
▲ При считывании данных по формату %c пробельные символы не игнорируются.
Чтобы проигнорировать пробельные символы при считывании по формату %c нужно перед спецификатором %с добавить пробел, т.е. заменить "%с" на " %c".

И хотя можно добавлять сколько угодно пробельных символов в формат строку, всё же в программах следует избегать лишних пробельных символов в формат-строке. Например, заменить "%d%d" на "%d %d" — нормально, так как это улучшает читаемость строки формата, но писать что-то вроде "\t\n%d\t\t%d" не стоит.

■ Другие символы в формат-строке
Если в формат-строке функции scanf встречается какой-то другой символ (не спецификатор формата и не пробельный символ), то это означает, что в потоке ввода на этом месте должен присутствовать точно такой же символ.
Например, формат-строка вида "%d,%d" означает, что во входном потоке должны быть записаны два целых числа, причём сразу за первым числом должна стоять запятая.

▼ Два основных правила работы с функцией scanf:
— количество спецификаторов формата должно совпадать с количеством данных для ввода;
— спецификаторы формата должны точно соответствовать типами переменных, переданным в функцию scanf.

■ Функция scanf возвращает целое число — количество переменных, в которые функция scanf успешно записала значения из входного потока. Давайте посмотрим на это значение.
values_read = scanf("%d,%d", &a, &b);

int a, b;
float real_f;
double real_d;
char ch;
scanf("%d %d", &a, &b);  // считает два целых числа, эквивалентно scanf("%d%d", &a, &b);
scanf("%d%f", &a, &real_f); // считает целое и вещественное число
scanf(" %c %lf", &ch, &real_d); // считает первый непробельный символ в ch 
                                // и вещественное число в real_d
scanf("%c", &ch); // считает один произвольный символ (включая пробельные символы) в ch
var_count=scanf("%d%d", &a, &b);

▲ Перевод шахматной нотации из "Nb1  -  c3" в |Nc3|
scanf("%c%*c%*d - %c%d", &figure, &x, &y);
printf("|%c%c%d|", figure, x, y);

▲ 
%*c - Читает 1 символ, но не сохраняет (звёздочка говорит "пропустить")
%*d - Читает целое число, но не сохраняет

▲
Чтобы прочитать ровно три цифры (и не больше) из непрерывной последовательности чисел, в scanf нужно указать ширину поля перед спецификатором:
scanf("%3d", &x);




§4.1 Арифметика в си
======================================

ОЧЕНЬ краткая шпаргалка по материалам урока
Основные арифметические операторы:
+ -- сложение
- -- вычитание
* -- умножение
/ -- деление (для целых чисел -- целочисленное деление) 
% -- остаток от деления (только для целых чисел)
Ключевые особенности: 

Целочисленное деление
7 / 2 → 3 (делим, а потом отбрасываем дробную часть)

Вещественное деление  
Один из операндов должен быть вещественного типа  
(float) 7 /  2 → 3.5
или:
(double) 7 /  2 → 3.5 // так приходилось писать при решении тестов

Остаток от деления  
Работает ТОЛЬКО с целыми числами.
Знак остатка = знак первого операнда  
-10 % 3 → -1  
10 % -3 → 1

Явное приведение типа
Формат записи:
(имя типа) значение (int) 9.81 → 9 
(имя типа) переменная int x = 5; (float) x → 5.0 
​​​​​​​Нюансы:
В случае с переменной меняет только тип значения, участвующего в выражении. Тип переменной остаётся прежним.
При преобразовании из float/double в int дробная часть отбрасывается

■ Функция abs() работает только с целыми числами
Для дробных чисел нужно использовать
fabs() из <math.h>



§4.4 rand()
======================================
#include <stdio.h>   // чтобы пользоваться функцией printf
#include <stdlib.h>  // чтобы пользоваться функцией rand
int main(void)
{
	printf("%d\n", rand());
	return 0;
}

▲ Чтобы ограничить сверху диапазон генерируемых случайных чисел значением K  возьмите остаток от деления на K + 1:
rand() % (K + 1).

▲ Чтобы ограничить диапазон чисел, генерируемых функцией rand, снизу (слева) числом M используйте формулу M + rand():
printf("%d\n", 80 + rand();.

▲ Если нужно получить числа из отрезка [A, B], то можно воспользоваться следующей конструкцией:
A + rand() % (B - A + 1);.

■ 
srand(time(NULL));
printf("%d\n", 80 + rand()%(100 - 80 + 1));
printf("%d\n", 80 + rand()%(100 - 79));
printf("%d\n", 80 + rand()%21);
printf("%d\n", 80 + rand()%21);
printf("%d\n", 80 + rand()%21);
return 0;



§6.1 switch
======================================

■ общий синтаксис инструкции switch:

switch (управляющее_выражение) {
        case метка_1: [набор_инструкций_1]
        case метка_2: [набор_инструкций_2]
        case метка_3: [набор_инструкций_3]
        case метка_4: [набор_инструкций_4]
        ...
        [default: набор_инструкций_по-умолчанию]
}


■ Ограничения switch

В качестве управляющего выражения можно использовать:
— переменную целого типа, например: int;
— переменную типа char;
— любое выражение, результат которого будет целым числом или символом.

Каждая ветка case внутри инструкции switch должна иметь свою уникальную метку. В качестве метки можно использовать целые числа и одиночные символы:

int num = 3;

case 'a':       // корректно (одиночный символ)
case 7:         // корректно (целое число)
case num:       // ошибка (значение переменной не может быть меткой)
case 3.14:      // ошибка (вещественное число не может быть меткой)
case "A":       // ошибка (строка не может быть меткой)


■ Сквозное выполнение (проваливание) в инструкции switchСквозное выполнение (проваливание) в инструкции switch
<...> если есть совпадение в одной из веток case, то выполняются все инструкции, записанные после этой метки. Т.е. буквально все, ибо про остановку перед следующей меткой ничего не говорилось. Иначе говоря, выполнив все инструкции в текущей ветке программа не останавливается, а как бы "проваливается" в следующую ветку и начинает выполнять уже её инструкции и так до тех пор, пока не достигнет закрывающей скобки }.
Эта фича, унаследованная из языков ассемблера, позволяет писать очень эффективный код.


■ Инструкция break

break называют оператором безусловного выхода. Эта инструкция немедленно прерывает выполнение switch и переходит к коду, расположенному после закрывающей фигурной скобки }.
▲ Добавляйте break в каждую ветку, где нужно избежать "проваливания". Стандартный подход, позволяющий избегать ошибок, состоит в том, чтобы думать будто break это часть синтаксиса инструкции switch (как case) и cначала добавлять break в каждую ветку. И только потом явно удалять break там, где требуется "проваливание".


■ Нюансы switch

Ветка case может быть пустой, т.е. в ней может вовсе не быть инструкций.

<...>
case 'B': //используем проваливание
case 'b': 
    printf("GOOD!\n"); 
    break;
<...>

Пустые ветки и "проваливание" используются когда для различных вариантов нужно выполнить одинаковый код.

<...>
switch (answer) { 
        case 'B': 
        case 'b': 
                printf("GOOD!\n"); 
                break;
        case 'A': /* сквозное выполнение */
        case 'a': 
        case 'C': 
        case 'c': 
        case 'D': 
        case 'd': 
                printf("BAD!\n");
                break;
        default: // 
                printf("ERROR!\n"); 
                break;
}   <...>

■ Ветка default не является обязательной, но лучше всегда добавлять её в конце инструкции switch.

■ Вложенные switch
Инструкции switch могут быть вложенными, т.е. в любой ветке switch мы снова можем использовать switch.
▲ Инструкция break выходит только из текущей инструкции switch.




§6.2 Отношекния и логические операторы
======================================

>  — больше чем
>= — больше чем или равно
<  — меньше чем
<= — меньше чем или равно
== — равно
!= — не равно
!  — логическое НЕ
&& — логическое И
|| — логическое ИЛИ

■ В логических выражениях любое значение, отличное от числа нуль, интерпретируется как ИСТИНА.
Числа 0 и 0.0 интерпретируются как ЛОЖЬ.


■ Приоритет операторов сравнения и логических операторов

Операторы сравнения и логические операторы также имеют определённый приоритет.

действия в скобках ()
явное приведение типов
вызов и вычисление функций (например, sqrt(), cos() и пр.)
логическое НЕ !
умножение *, деление /, остаток от деления %
сложение +, вычитание -
сравнения <, >, <=, >=
проверка равенства и неравенства ==, !=
логическое И &&
логическое ИЛИ ||
присваивание =

